/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package dev.punchcafe.vngine.gb.codegen;

import dev.punchcafe.vngine.gb.codegen.narrative.NarrativeReader;
import dev.punchcafe.vngine.gb.codegen.narrative.config.ColorConfig;
import dev.punchcafe.vngine.gb.codegen.narrative.config.ImageConfig;
import dev.punchcafe.vngine.gb.codegen.narrative.config.NarrativeConfig;
import dev.punchcafe.vngine.gb.codegen.render.ComponentRenderer;
import dev.punchcafe.vngine.gb.imagegen.HexValueConfig;
import dev.punchcafe.vngine.gb.imagegen.PixelValue;
import dev.punchcafe.vngine.pom.PomLoader;
import lombok.Getter;
import org.simpleframework.xml.core.Persister;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.*;

import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toMap;

public class CodeGenerator {

    private static class AppArgs {

        private String outputFile;
        @Getter private String projectRootDirectory;

        public Optional<String> getOutputFile(){
            return Optional.ofNullable(this.outputFile);
        }

        public AppArgs mergeFlags(final Map<String, String> flags){
            this.outputFile = flags.get("o");
            return this;
        }

        public AppArgs mergeRootDirectory(final List<String> orderedArgs){
            this.projectRootDirectory = orderedArgs.get(0);
            return this;
        }
    }

    private static Map<String, String> parseFlags(String[] args){
        final Map<String,String> flags = new HashMap<>();
        int i = 0;
        while(i < args.length){
            if(args[i].startsWith("-")){
                flags.put(args[i].substring(1), args[i+1]);
                i += 2;
            } else {
                i++;
            }
        }
        return flags;
    }

    private static List<String> parseOrderedArgs(String[] args){
        final List<String> orderedArgs = new ArrayList<>();
        int i = 0;
        while(i < args.length){
            if(args[i].startsWith("-")){
                i += 2;
            } else {
                orderedArgs.add(args[i]);
                i++;
            }
        }
        return orderedArgs;
    }

    private static AppArgs convertArgs(String[] args){
        final var argsModel = new AppArgs();
        return argsModel.mergeFlags(parseFlags(args))
                .mergeRootDirectory(parseOrderedArgs(args));
    }

    public static void main(String[] args) throws IOException {
         new CodeGenerator().run(args);
    }

    private final Persister serializer = new Persister();

    public void run(final String[] args) throws IOException {
        final CodeGenerator codeGenerator = new CodeGenerator();
        codeGenerator.run(CodeGenerator.convertArgs(args));
    }

    public void run(final AppArgs appArgs) throws IOException {
        run(new File(appArgs.projectRootDirectory), appArgs.getOutputFile().orElse("./game.c"));
    }

    public void run(final File vngProjectRoot, final String scriptDestination) throws IOException {
        final var narrativeReader = new NarrativeReader();

        final var assetsDirectory = vngProjectRoot.listFiles((root, fileName) -> fileName.equals("assets"))[0];
        final var narrativeConfig = Optional.ofNullable(assetsDirectory.listFiles((file, name) -> name.equals("config.vnx")))
                .stream()
                .flatMap(Arrays::stream)
                .map(this::parseNarrativeConfigFile)
                .findAny()
                .orElseThrow();

        final HexValueConfig hexConfig = extractHexConfig(narrativeConfig.getImageConfig());

        final var gameConfig = PomLoader.forGame(vngProjectRoot, narrativeReader).loadGameConfiguration();
        final var rendererFactory = new RendererFactory(gameConfig, assetsDirectory, narrativeConfig, hexConfig);


        final var allComponents = Arrays.stream(rendererFactory.getClass().getDeclaredMethods())
                .filter(method -> method.isAnnotationPresent(RendererSupplier.class))
                .map(supplierMethod -> getFromMethod(supplierMethod, rendererFactory))
                .collect(toList());

        final var scriptRenderer = ScriptRenderer.builder()
                .componentRenderers(allComponents)
                .build();

        final var renderedScript = scriptRenderer.render();
        final var out = new BufferedWriter(new FileWriter(scriptDestination));
        out.write(renderedScript);
        out.close();
    }

    private HexValueConfig extractHexConfig(ImageConfig imageConfig) {
        final var hexMap = imageConfig.getPaletteConfig().getColors().stream()
                .map(this::convertColorToEntry)
                .collect(toMap(Map.Entry::getKey, Map.Entry::getValue));
        return HexValueConfig.builder()
                .hexConversions(hexMap)
                .build();
    }

    private Map.Entry<String, PixelValue> convertColorToEntry(final ColorConfig color){
        // TODO: make this a model which does checks for us.
        return Map.entry(color.getHex(), pixelValueFromString(color.getValue()));
    }

    private PixelValue pixelValueFromString(final String val){
        switch (val){
            case "0":
                return PixelValue.VAL_0;
            case "1":
                return PixelValue.VAL_1;
            case "2":
                return PixelValue.VAL_2;
            case "3":
                return PixelValue.VAL_3;
            default:
                throw new UnsupportedOperationException();
        }
    }

    private NarrativeConfig parseNarrativeConfigFile(final File file){
        try {
            return serializer.read(NarrativeConfig.class, file);
        } catch (Exception e) {
            throw new RuntimeException();
        }
    }

    private ComponentRenderer getFromMethod(final Method method, final RendererFactory factory) {
        try {
            return (ComponentRenderer) method.invoke(factory);
        } catch (Exception e) {
            throw new RuntimeException();
        }
    }
}
